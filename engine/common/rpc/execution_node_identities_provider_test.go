package rpc_test

import (
	"context"
	"testing"

	"github.com/dgraph-io/badger/v2"
	"github.com/rs/zerolog"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"

	accessmock "github.com/onflow/flow-go/engine/access/mock"
	"github.com/onflow/flow-go/engine/access/rpc/backend"
	backendmock "github.com/onflow/flow-go/engine/access/rpc/backend/mock"
	connectionmock "github.com/onflow/flow-go/engine/access/rpc/connection/mock"
	commonrpc "github.com/onflow/flow-go/engine/common/rpc"
	"github.com/onflow/flow-go/engine/common/version"
	"github.com/onflow/flow-go/fvm/blueprints"
	"github.com/onflow/flow-go/model/flow"
	"github.com/onflow/flow-go/module"
	"github.com/onflow/flow-go/module/counters"
	protocol "github.com/onflow/flow-go/state/protocol/mock"
	bstorage "github.com/onflow/flow-go/storage/badger"
	storagemock "github.com/onflow/flow-go/storage/mock"
	"github.com/onflow/flow-go/utils/unittest"
)

type Suite struct {
	suite.Suite

	state    *protocol.State
	snapshot *protocol.Snapshot
	log      zerolog.Logger

	blocks             *storagemock.Blocks
	headers            *storagemock.Headers
	collections        *storagemock.Collections
	transactions       *storagemock.Transactions
	receipts           *storagemock.ExecutionReceipts
	results            *storagemock.ExecutionResults
	transactionResults *storagemock.LightTransactionResults
	events             *storagemock.Events
	txErrorMessages    *storagemock.TransactionResultErrorMessages

	db                  *badger.DB
	dbDir               string
	lastFullBlockHeight *counters.PersistentStrictMonotonicCounter
	versionControl      *version.VersionControl

	colClient              *accessmock.AccessAPIClient
	execClient             *accessmock.ExecutionAPIClient
	historicalAccessClient *accessmock.AccessAPIClient

	connectionFactory *connectionmock.ConnectionFactory
	communicator      *backendmock.Communicator

	chainID  flow.ChainID
	systemTx *flow.TransactionBody
}

func TestHandler(t *testing.T) {
	suite.Run(t, new(Suite))
}

func (suite *Suite) SetupTest() {
	suite.log = zerolog.New(zerolog.NewConsoleWriter())
	suite.state = new(protocol.State)
	suite.snapshot = new(protocol.Snapshot)
	header := unittest.BlockHeaderFixture()
	params := new(protocol.Params)
	params.On("FinalizedRoot").Return(header, nil)
	params.On("SporkID").Return(unittest.IdentifierFixture(), nil)
	params.On("ProtocolVersion").Return(uint(unittest.Uint64InRange(10, 30)), nil)
	params.On("SporkRootBlockHeight").Return(header.Height, nil)
	params.On("SealedRoot").Return(header, nil)
	suite.state.On("Params").Return(params)

	suite.blocks = new(storagemock.Blocks)
	suite.headers = new(storagemock.Headers)
	suite.transactions = new(storagemock.Transactions)
	suite.collections = new(storagemock.Collections)
	suite.receipts = new(storagemock.ExecutionReceipts)
	suite.results = new(storagemock.ExecutionResults)
	suite.colClient = new(accessmock.AccessAPIClient)
	suite.execClient = new(accessmock.ExecutionAPIClient)
	suite.transactionResults = storagemock.NewLightTransactionResults(suite.T())
	suite.events = storagemock.NewEvents(suite.T())
	suite.chainID = flow.Testnet
	suite.historicalAccessClient = new(accessmock.AccessAPIClient)
	suite.connectionFactory = connectionmock.NewConnectionFactory(suite.T())

	suite.communicator = new(backendmock.Communicator)

	var err error
	suite.systemTx, err = blueprints.SystemChunkTransaction(flow.Testnet.Chain())
	suite.Require().NoError(err)

	suite.db, suite.dbDir = unittest.TempBadgerDB(suite.T())
	suite.lastFullBlockHeight, err = counters.NewPersistentStrictMonotonicCounter(
		bstorage.NewConsumerProgress(suite.db, module.ConsumeProgressLastFullBlockHeight),
		0,
	)
	suite.Require().NoError(err)
}

// TestExecutionNodesForBlockID tests the ExecutionNodesForBlockID used for serving all API calls
// that need to talk to an execution node.
func (suite *Suite) TestExecutionNodesForBlockID() {

	totalReceipts := 5

	block := unittest.BlockFixture()

	// generate one execution node identities for each receipt assuming that each ER is generated by a unique exec node
	allExecutionNodes := unittest.IdentityListFixture(totalReceipts, unittest.WithRole(flow.RoleExecution))

	// one execution result for all receipts for this block
	executionResult := unittest.ExecutionResultFixture()

	// generate execution receipts
	receipts := make(flow.ExecutionReceiptList, totalReceipts)
	for j := 0; j < totalReceipts; j++ {
		r := unittest.ReceiptForBlockFixture(&block)
		r.ExecutorID = allExecutionNodes[j].NodeID
		er := *executionResult
		r.ExecutionResult = er
		receipts[j] = r
	}

	currentAttempt := 0
	attempt1Receipts, attempt2Receipts, attempt3Receipts := receipts, receipts, receipts

	// setup receipts storage mock to return different list of receipts on each call
	suite.receipts.
		On("ByBlockID", block.ID()).Return(
		func(id flow.Identifier) flow.ExecutionReceiptList {
			switch currentAttempt {
			case 0:
				currentAttempt++
				return attempt1Receipts
			case 1:
				currentAttempt++
				return attempt2Receipts
			default:
				currentAttempt = 0
				return attempt3Receipts
			}
		},
		func(id flow.Identifier) error { return nil })

	suite.snapshot.On("Identities", mock.Anything).Return(
		func(filter flow.IdentityFilter[flow.Identity]) flow.IdentityList {
			// apply the filter passed in to the list of all the execution nodes
			return allExecutionNodes.Filter(filter)
		},
		func(flow.IdentityFilter[flow.Identity]) error { return nil })
	suite.state.On("Final").Return(suite.snapshot, nil).Maybe()

	var preferredENIdentifiers flow.IdentifierList
	var fixedENIdentifiers flow.IdentifierList

	testExecutionNodesForBlockID := func(preferredENs, fixedENs, expectedENs flow.IdentityList) {

		if preferredENs != nil {
			preferredENIdentifiers = preferredENs.NodeIDs()
		}
		if fixedENs != nil {
			fixedENIdentifiers = fixedENs.NodeIDs()
		}

		if expectedENs == nil {
			expectedENs = flow.IdentityList{}
		}

		execProvider := commonrpc.NewExecutionNodeIdentitiesProvider(
			suite.log,
			suite.state,
			suite.receipts,
			preferredENIdentifiers,
			fixedENIdentifiers,
		)

		allExecNodes, err := execProvider.ExecutionNodesForBlockID(context.Background(), block.ID())
		require.NoError(suite.T(), err)

		execNodeSelectorFactory := backend.NewNodeSelectorFactory(false)
		execSelector, err := execNodeSelectorFactory.SelectNodes(allExecNodes)
		require.NoError(suite.T(), err)

		actualList := flow.IdentitySkeletonList{}
		for actual := execSelector.Next(); actual != nil; actual = execSelector.Next() {
			actualList = append(actualList, actual)
		}

		{
			expectedENs := expectedENs.ToSkeleton()
			if len(expectedENs) > commonrpc.MaxNodesCnt {
				for _, actual := range actualList {
					require.Contains(suite.T(), expectedENs, actual)
				}
			} else {
				require.ElementsMatch(suite.T(), actualList, expectedENs)
			}
		}
	}
	// if we don't find sufficient receipts, ExecutionNodesForBlockID should return a list of random ENs
	suite.Run("insufficient receipts return random ENs in State", func() {
		// return no receipts at all attempts
		attempt1Receipts = flow.ExecutionReceiptList{}
		attempt2Receipts = flow.ExecutionReceiptList{}
		attempt3Receipts = flow.ExecutionReceiptList{}
		suite.state.On("AtBlockID", mock.Anything).Return(suite.snapshot)

		execProvider := commonrpc.NewExecutionNodeIdentitiesProvider(
			suite.log,
			suite.state,
			suite.receipts,
			flow.IdentifierList{},
			flow.IdentifierList{},
		)

		allExecNodes, err := execProvider.ExecutionNodesForBlockID(context.Background(), block.ID())
		require.NoError(suite.T(), err)

		execNodeSelectorFactory := backend.NewNodeSelectorFactory(false)
		execSelector, err := execNodeSelectorFactory.SelectNodes(allExecNodes)
		require.NoError(suite.T(), err)

		actualList := flow.IdentitySkeletonList{}
		for actual := execSelector.Next(); actual != nil; actual = execSelector.Next() {
			actualList = append(actualList, actual)
		}

		require.Equal(suite.T(), len(actualList), commonrpc.MaxNodesCnt)
	})

	// if no preferred or fixed ENs are specified, the ExecutionNodesForBlockID function should
	// return the exe node list without a filter
	suite.Run("no preferred or fixed ENs", func() {
		testExecutionNodesForBlockID(nil, nil, allExecutionNodes)
	})
	// if only fixed ENs are specified, the ExecutionNodesForBlockID function should
	// return the fixed ENs list
	suite.Run("two fixed ENs with zero preferred EN", func() {
		// mark the first two ENs as fixed
		fixedENs := allExecutionNodes[0:2]
		expectedList := fixedENs
		testExecutionNodesForBlockID(nil, fixedENs, expectedList)
	})
	// if only preferred ENs are specified, the ExecutionNodesForBlockID function should
	// return the preferred ENs list
	suite.Run("two preferred ENs with zero fixed EN", func() {
		// mark the first two ENs as preferred
		preferredENs := allExecutionNodes[0:2]
		expectedList := allExecutionNodes[0:commonrpc.MaxNodesCnt]
		testExecutionNodesForBlockID(preferredENs, nil, expectedList)
	})
	// if both are specified, the ExecutionNodesForBlockID function should
	// return the preferred ENs list
	suite.Run("four fixed ENs of which two are preferred ENs", func() {
		// mark the first four ENs as fixed
		fixedENs := allExecutionNodes[0:5]
		// mark the first two of the fixed ENs as preferred ENs
		preferredENs := fixedENs[0:2]
		expectedList := fixedENs[0:commonrpc.MaxNodesCnt]
		testExecutionNodesForBlockID(preferredENs, fixedENs, expectedList)
	})
	// if both are specified, but the preferred ENs don't match the ExecutorIDs in the ER,
	// the ExecutionNodesForBlockID function should return the fixed ENs list
	suite.Run("four fixed ENs of which two are preferred ENs but have not generated the ER", func() {
		// mark the first two ENs as fixed
		fixedENs := allExecutionNodes[0:2]
		// specify two ENs not specified in the ERs as preferred
		preferredENs := unittest.IdentityListFixture(2, unittest.WithRole(flow.RoleExecution))
		// add one more node ID besides of the fixed ENs list cause expected length of the list should be maxNodesCnt
		expectedList := append(fixedENs, allExecutionNodes[2])
		testExecutionNodesForBlockID(preferredENs, fixedENs, expectedList)
	})
	// if execution receipts are not yet available, the ExecutionNodesForBlockID function should retry twice
	suite.Run("retry execution receipt query", func() {
		// on first attempt, no execution receipts are available
		attempt1Receipts = flow.ExecutionReceiptList{}
		// on second attempt ony one is available
		attempt2Receipts = flow.ExecutionReceiptList{receipts[0]}
		// on third attempt all receipts are available
		attempt3Receipts = receipts
		currentAttempt = 0
		// mark the first two ENs as preferred
		preferredENs := allExecutionNodes[0:2]
		expectedList := allExecutionNodes[0:commonrpc.MaxNodesCnt]
		testExecutionNodesForBlockID(preferredENs, nil, expectedList)
	})
	// if preferredENIdentifiers was set and there are less than maxNodesCnt nodes selected than check the order
	// of adding ENs ids
	suite.Run("add nodes in the correct order", func() {
		//  mark the first EN as preferred
		preferredENIdentifiers = allExecutionNodes[0:1].NodeIDs()
		//  mark the fourth EN with receipt
		executorIDs := allExecutionNodes[3:4].NodeIDs()

		receiptNodes := allExecutionNodes[3:4]   // any EN with a receipt
		preferredNodes := allExecutionNodes[0:1] // preferred EN node not already selected
		additionalNode := allExecutionNodes[1:2] // any EN not already selected

		expectedOrder := flow.IdentityList{
			receiptNodes[0],
			preferredNodes[0],
			additionalNode[0],
		}

		execProvider := commonrpc.NewExecutionNodeIdentitiesProvider(
			suite.log,
			suite.state,
			suite.receipts,
			preferredENIdentifiers,
			flow.IdentifierList{},
		)

		chosenIDs := execProvider.ChooseFromPreferredENIDs(allExecutionNodes, executorIDs)

		require.ElementsMatch(suite.T(), chosenIDs, expectedOrder)
		require.Equal(suite.T(), len(chosenIDs), commonrpc.MaxNodesCnt)
	})
}
