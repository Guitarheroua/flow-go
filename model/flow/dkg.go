package flow

// DKGEndState captures the final state of a completed DKG.
type DKGEndState uint32

const (
	// DKGEndStateUnknown - zero value for this enum, indicates unset value
	DKGEndStateUnknown DKGEndState = iota
	// DKGEndStateSuccess - the DKG completed, this node has a valid beacon key.
	DKGEndStateSuccess
	// DKGEndStateInconsistentKey - the DKG completed, this node has an invalid beacon key.
	DKGEndStateInconsistentKey
	// DKGEndStateNoKey - this node did not store a key, typically caused by a crash mid-DKG.
	DKGEndStateNoKey
	// DKGEndStateDKGFailure - the underlying DKG library reported an error.
	DKGEndStateDKGFailure
)

func (state DKGEndState) String() string {
	switch state {
	case DKGEndStateSuccess:
		return "DKGEndStateSuccess"
	case DKGEndStateInconsistentKey:
		return "DKGEndStateInconsistentKey"
	case DKGEndStateNoKey:
		return "DKGEndStateNoKey"
	case DKGEndStateDKGFailure:
		return "DKGEndStateDKGFailure"
	default:
		return "DKGEndStateUnknown"
	}
}

// DKGIndexMap completely describes the DKG committee 𝒟 of size |𝒟| = n.
// Flow's random beacon utilizes a threshold signature scheme run by the committee 𝒟.
// In the formal cryptographic protocol for a threshold signature with n parties,
// the individual participants are identified by n public distinct non-negative integers, or simply indices.
// These public indices are agreed upon by all participants and are used by the low-level
// Shamir Secret Sharing [SSS].
// In Flow, the threshold signature keys are generated by a Distributed Key Generation [DKG]. The DKG
// therefore requires the same SSS indices as an input to generate the private key shares of each participant.
// Accordingly, the lower-level cryptographic implementation of the threshold signature and DKG
// works with these indices. The lower-level cryptographic interface requires that the indices are exactly
// the set {0, 1, ..., n-1}.
//
// On the protocol level, only consensus nodes (identified by their nodeIDs) are allowed to contribute
// random beacon signature shares. Hence, the protocol level needs to map nodeIDs to the indices when
// calling into the lower-level cryptographic primitives.
//
// Formal specification:
//   - DKGIndexMap completely describes the DKG committee. If n parties are authorized to participate
//     in the DKG, DKGIndexMap must contain exactly n elements, i.e. n = len(DKGIndexMap)
//   - The values in DKGIndexMap must form the set {0, 1, …, n-1}, as required by the low level cryptography
//     module (convention simplifying the implementation).
//
// CAUTION: It is important to cleanly differentiate between the consensus committee 𝒞, the DKG committee 𝒟
// and the committee ℛ:
//   - For an epoch, the consensus committee 𝒞 contains all nodes that are authorized to vote for blocks. Authority
//     to vote (i.e. membership in the consensus committee) is irrevocably granted for an epoch (though, honest nodes
//     will reject votes and proposals from ejected nodes; nevertheless, ejected nodes formally remain members of
//     the consensus committee).
//   - The DKG committee 𝒟 is the set of parties that were authorized to participate in the DKG (happy path; or
//     eligible to receive a private key share from an alternative source on the fallback path). Mathematically,
//     the DKGIndexMap is a bijective function DKGIndexMap: 𝒟 ↦ {0,1,…,n-1}.
//   - Only consensus nodes are allowed to contribute to the random beacon. Informally, we define ℛ as the
//     as the subset of the consensus committee (ℛ ⊆ 𝒞), which _successfully_ completed the DKG (hence ℛ ⊆ 𝒟).
//     Specifically, r ∈ ℛ iff and only if r has a private Random Beacon key share matching the respective public
//     key share in the `EpochCommit` event. In other words, consensus nodes are in ℛ iff and only if they are able
//     to submit valid random beacon votes. Based on this definition we note that ℛ ⊆ (𝒟 ∩ 𝒞).
//
// The protocol explicitly ALLOWS additional parties outside the current epoch's consensus committee to participate.
// In particular, there can be a key-value pair (d,i) ∈ DKGIndexMap, such that the nodeID d is *not* a consensus
// committee member, i.e. d ∉ 𝒞. This may be the case when a DKG is run off-protocol to bootstrap the network.
// In terms of sets, this implies we must consistently work with the relatively general
// assumption that 𝒟 \ 𝒞 ≠ ∅ and 𝒞 \ 𝒟 ≠ ∅.
// Nevertheless, in the vast majority of cases (happy path, roughly 98% of epochs) it will be the case that 𝒟 = 𝒞.
// Therefore, we can optimize for the case 𝒟 = 𝒞, as long as we still support the more general case 𝒟 ≠ 𝒞.
// Broadly, this makes the protocol more robust against temporary disruptions and sudden, large fluctuations in node
// participation.
//
// Nevertheless, there is an important liveness constraint: the committee ℛ should be a large number of nodes.
// Specifically, an honest supermajority of consensus nodes must contain enough successful DKG participants
// (about |𝒟|/2 + 1) to produce a valid group signature for the random beacon at each block [1, 3].
// Therefore, we have the approximate lower bound |ℛ| ≳ n/2 + 1 = |𝒟|/2 + 1 = len(DKGIndexMap)/2 + 1.
// Operating close to this lower bound would require that every random beacon key-holder ϱ ∈ ℛ remaining in the consensus committee is honest
// (incl. quickly responsive) *all the time*. Such a reliability assumption is unsuited for decentralized production networks.
// To reject configurations that are vulnerable to liveness failures, the protocol uses the threshold `t_safety`
// (heuristic, see [2]), which is implemented on the smart contract level.
// Ideally, |ℛ| and therefore |𝒟 ∩ 𝒞| (given that |ℛ| <= |𝒟 ∩ 𝒞|) should be well above 70% . |𝒟|.
// Values in the range 70%-62% of |𝒟| should be considered for short-term recovery cases.
// Values of 62% * |𝒟| or lower (i.e. |ℛ| ≤ 0.62·|𝒟|) are not recommended for any
// production network, as single-node crashes may already be enough to halt consensus.
//
// For further details, see
//   - [1] https://www.notion.so/flowfoundation/Threshold-Signatures-7e26c6dd46ae40f7a83689ba75a785e3?pvs=4
//   - [2] https://www.notion.so/flowfoundation/DKG-contract-success-threshold-86c6bf2b92034855b3c185d7616eb6f1?pvs=4
//   - [3] https://www.notion.so/flowfoundation/Architecture-for-Concurrent-Vote-Processing-41704666bc414a03869b70ba1043605f?pvs=4
type DKGIndexMap map[Identifier]int
